# Name: Create Release from Manifest
# Developer: incpi
# Description: 
# This workflow creates a GitHub release based on the version extracted from 'manifest.json'.
# The zip file is located in the 'bin' directory, renamed according to the naming convention, and attached to the release.
# Version extracted from 'manifest.json' will be used for both the tag and release name.
#__________________________________________________________________________________________________________________________

name: Create Release from Manifest

on:
  push:
    branches:
      - main  # Change this to your default branch

jobs:
  generate_and_commit:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2

      - name: Run Shell Script to Generate File
        run: |
          chmod +x ./zipFiles.sh
          ./zipFiles.sh

      - name: Configure Git
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "GitHub Action"

      - name: Commit Changes
        run: |
          git commit -m "Add new files generated by zipFiles.sh on $(date)"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Automatically provided by GitHub

      - name: Prevent re-triggering the Workflow
        if: contains(github.event.head_commit.message, 'Add new files generated by zipFiles.sh')
        run: echo "Skipping because this is the automated commit message from our script."

  release:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "16"

      #  This step uses jq to extract the version field from the manifest.json file
      - name: Extract version from manifest.json
        id: get_version
        run: |
          VERSION=$(jq -r '.version' manifest.json)
          
          # Check if the version is already in the format 1.1.1.1
          if [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            CLEAN_VERSION="$VERSION"  # Use the version as is
          else
            CLEAN_VERSION=$(echo "$VERSION" | awk -F. '{print $1"."$2"."$3}')  # Clean to 1.1.1
          fi

          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "CLEAN_VERSION=$CLEAN_VERSION" >> $GITHUB_ENV

      # Looks for the zip file within the bin folder
      - name: Find zip files in bin
        id: find_zips
        run: |
          ZIP_FILES=$(find ./bin -type f -name "*.zip" | tr '\n' '|')  # Create a pipe-separated list
          echo "Found zip files: $ZIP_FILES"
          echo "ZIP_FILES=$ZIP_FILES" >> $GITHUB_ENV

        # Utilizes softprops/action-gh-release@v1 to create a release with the version as the tag and release name
      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: "Version_${{ env.CLEAN_VERSION }}"
          name: "Extension @${{ env.CLEAN_VERSION }}" # Release name
          body: "Release created with version ${{ env.VERSION }}"

      # Ensures that the zip file is uploaded with the correct name and content type
      - name: Attach zip files to release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Use the GitHub token for authentication
        run: |
          IFS='|' read -r -a ZIP_ARRAY <<< "${{ env.ZIP_FILES }}"  # Split the pipe-separated list into an array
          for ZIP_FILE in "${ZIP_ARRAY[@]}"; do
            ZIP_BASENAME=$(basename "$ZIP_FILE")  # Get the clean zip file name
            echo "Attaching $ZIP_BASENAME"
            gh release upload "Version_${{ env.CLEAN_VERSION }}" "$ZIP_FILE" --clobber 
          done
